/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#include "previewsubscribe.h"
#include "debughelper.h"

#if defined(Q_OS_IOS)
namespace gpb = google_public::protobuf;
#else
namespace gpb = google::protobuf;
#endif

using namespace nzmqt;

namespace pathview {

/** Generic Preview Subscribe implementation */
PreviewSubscribe::PreviewSubscribe(QObject *parent) :
    QObject(parent),
    m_ready(false),
    m_debugName("Preview Subscribe"),
    m_socketUri(""),
    m_context(nullptr),
    m_socket(nullptr),
    m_state(Down),
    m_previousState(Down),
    m_fsm(nullptr),
    m_errorString("")
{

    m_fsm = new QStateMachine(this);
    QState *downState = new QState(m_fsm);
    connect(downState, &QState::entered, this, &PreviewSubscribe::fsmDownEntered, Qt::QueuedConnection);
    QState *tryingState = new QState(m_fsm);
    connect(tryingState, &QState::entered, this, &PreviewSubscribe::fsmTryingEntered, Qt::QueuedConnection);
    QState *upState = new QState(m_fsm);
    connect(upState, &QState::entered, this, &PreviewSubscribe::fsmUpEntered, Qt::QueuedConnection);
    m_fsm->setInitialState(downState);
    m_fsm->start();

    connect(this, &PreviewSubscribe::fsmDownConnect,
            this, &PreviewSubscribe::fsmDownConnectQueued, Qt::QueuedConnection);
    downState->addTransition(this, &PreviewSubscribe::fsmDownConnectQueued, tryingState);
    connect(this, &PreviewSubscribe::fsmTryingConnected,
            this, &PreviewSubscribe::fsmTryingConnectedQueued, Qt::QueuedConnection);
    tryingState->addTransition(this, &PreviewSubscribe::fsmTryingConnectedQueued, upState);
    connect(this, &PreviewSubscribe::fsmTryingDisconnect,
            this, &PreviewSubscribe::fsmTryingDisconnectQueued, Qt::QueuedConnection);
    tryingState->addTransition(this, &PreviewSubscribe::fsmTryingDisconnectQueued, downState);
    connect(this, &PreviewSubscribe::fsmUpMessageReceived,
            this, &PreviewSubscribe::fsmUpMessageReceivedQueued, Qt::QueuedConnection);
    upState->addTransition(this, &PreviewSubscribe::fsmUpMessageReceivedQueued, upState);
    connect(this, &PreviewSubscribe::fsmUpDisconnect,
            this, &PreviewSubscribe::fsmUpDisconnectQueued, Qt::QueuedConnection);
    upState->addTransition(this, &PreviewSubscribe::fsmUpDisconnectQueued, downState);

    connect(this, &PreviewSubscribe::fsmDownConnect,
            this, &PreviewSubscribe::fsmDownConnectEvent, Qt::QueuedConnection);
    connect(this, &PreviewSubscribe::fsmTryingConnected,
            this, &PreviewSubscribe::fsmTryingConnectedEvent, Qt::QueuedConnection);
    connect(this, &PreviewSubscribe::fsmTryingDisconnect,
            this, &PreviewSubscribe::fsmTryingDisconnectEvent, Qt::QueuedConnection);
    connect(this, &PreviewSubscribe::fsmUpMessageReceived,
            this, &PreviewSubscribe::fsmUpMessageReceivedEvent, Qt::QueuedConnection);
    connect(this, &PreviewSubscribe::fsmUpDisconnect,
            this, &PreviewSubscribe::fsmUpDisconnectEvent, Qt::QueuedConnection);

    m_context = new PollingZMQContext(this, 1);
    connect(m_context, &PollingZMQContext::pollError,
            this, &PreviewSubscribe::socketError);
    m_context->start();

     connect(this, &PreviewSubscribe::startSignal,
             this, &PreviewSubscribe::startSlot, Qt::QueuedConnection);
     connect(this, &PreviewSubscribe::stopSignal,
             this, &PreviewSubscribe::stopSlot, Qt::QueuedConnection);
     connect(this, &PreviewSubscribe::connectedSignal,
             this, &PreviewSubscribe::connectedSlot, Qt::QueuedConnection);
}

PreviewSubscribe::~PreviewSubscribe()
{
    stopSocket();

    if (m_context != nullptr)
    {
        m_context->stop();
        m_context->deleteLater();
        m_context = nullptr;
    }
}

/** Add a topic that should be subscribed **/
void PreviewSubscribe::addSocketTopic(const QString &name)
{
    m_socketTopics.insert(name);
}

/** Removes a topic from the list of topics that should be subscribed **/
void PreviewSubscribe::removeSocketTopic(const QString &name)
{
    m_socketTopics.remove(name);
}

/** Clears the the topics that should be subscribed **/
void PreviewSubscribe::clearSocketTopics()
{
    m_socketTopics.clear();
}

/** Connects the 0MQ sockets */
bool PreviewSubscribe::startSocket()
{
    m_socket = m_context->createSocket(ZMQSocket::TYP_SUB, this);
    m_socket->setLinger(0);

    try {
        m_socket->connectTo(m_socketUri);
    }
    catch (const zmq::error_t &e) {
        QString errorString;
        errorString = QString("Error %1: ").arg(e.num()) + QString(e.what());
        //updateState(SocketError, errorString); TODO
        return false;
    }

    connect(m_socket, &ZMQSocket::messageReceived,
            this, &PreviewSubscribe::processSocketMessage);


    foreach(QString topic, m_socketTopics)
    {
        m_socket->subscribeTo(topic.toLocal8Bit());
    }

#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "sockets connected" << m_socketUri);
#endif

    return true;
}

/** Disconnects the 0MQ sockets */
void PreviewSubscribe::stopSocket()
{
    if (m_socket != nullptr)
    {
        m_socket->close();
        m_socket->deleteLater();
        m_socket = nullptr;
    }
}

/** Processes all message received on socket */
void PreviewSubscribe::processSocketMessage(const QList<QByteArray> &messageList)
{
    pb::Container &rx = m_socketRx;
    QByteArray topic;

    if (messageList.length() < 2)  // in case we received insufficient data
    {
        return;
    }

    // we only handle the first two messges
    topic = messageList.at(0);
    rx.ParseFromArray(messageList.at(1).data(), messageList.at(1).size());

#ifdef QT_DEBUG
    std::string s;
    gpb::TextFormat::PrintToString(rx, &s);
    DEBUG_TAG(3, m_debugName, "server message" << QString::fromStdString(s));
#endif

    // react to any incoming message

    if (m_state == Up)
    {
        emit fsmUpMessageReceived();
    }

    emit socketMessageReceived(topic, rx);
}

void PreviewSubscribe::socketError(int errorNum, const QString &errorMsg)
{
    QString errorString;
    errorString = QString("Error %1: ").arg(errorNum) + errorMsg;
    //updateState(SocketError, errorString);  TODO
}

void PreviewSubscribe::fsmDownEntered()
{
    if (m_previousState != Down)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State DOWN");
#endif
        m_previousState = Down;
        emit stateChanged(m_state);
    }
}

void PreviewSubscribe::fsmDownConnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event CONNECT");
#endif

    m_state = Trying;
    startSocket();
    connected();
}

void PreviewSubscribe::fsmTryingEntered()
{
    if (m_previousState != Trying)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State TRYING");
#endif
        m_previousState = Trying;
        emit stateChanged(m_state);
    }
}

void PreviewSubscribe::fsmTryingConnectedEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event CONNECTED");
#endif

    m_state = Up;
}

void PreviewSubscribe::fsmTryingDisconnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event DISCONNECT");
#endif

    m_state = Down;
    stopSocket();
}

void PreviewSubscribe::fsmUpEntered()
{
    if (m_previousState != Up)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State UP");
#endif
        m_previousState = Up;
        emit stateChanged(m_state);
    }
}

void PreviewSubscribe::fsmUpMessageReceivedEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event MESSAGE RECEIVED");
#endif

    m_state = Up;
}

void PreviewSubscribe::fsmUpDisconnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event DISCONNECT");
#endif

    m_state = Down;
    stopSocket();
}

/** start trigger */
void PreviewSubscribe::start()
{
    emit startSignal(QPrivateSignal());
}

/** start queued trigger function */
void PreviewSubscribe::startSlot()
{
    if (m_state == Down) {
        emit fsmDownConnect();
    }
}

/** stop trigger */
void PreviewSubscribe::stop()
{
    emit stopSignal(QPrivateSignal());
}

/** stop queued trigger function */
void PreviewSubscribe::stopSlot()
{
    if (m_state == Up) {
        emit fsmUpDisconnect();
    }
}

/** connected trigger */
void PreviewSubscribe::connected()
{
    emit connectedSignal(QPrivateSignal());
}

/** connected queued trigger function */
void PreviewSubscribe::connectedSlot()
{
    if (m_state == Trying) {
        emit fsmTryingConnected();
    }
}
}; // namespace pathview
