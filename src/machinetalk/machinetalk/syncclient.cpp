/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#include "syncclient.h"
#include "debughelper.h"

#if defined(Q_OS_IOS)
namespace gpb = google_public::protobuf;
#else
namespace gpb = google::protobuf;
#endif

using namespace nzmqt;

namespace machinetalk {

/** Generic Sync Client implementation */
SyncClient::SyncClient(QObject *parent) :
    QObject(parent),
    QQmlParserStatus(),
    m_componentCompleted(false),
    m_ready(false),
    m_debugName("Sync Client"),
    m_syncChannel(nullptr),
    m_subChannel(nullptr),
    m_pubChannel(nullptr),
    m_state(Down),
    m_previousState(Down),
    m_fsm(nullptr),
    m_errorString("")
{
    // initialize sync channel
    m_syncChannel = new machinetalk::RpcClient(this);
    m_syncChannel->setDebugName(m_debugName + " - sync");
    connect(m_syncChannel, &machinetalk::RpcClient::socketUriChanged,
            this, &SyncClient::syncUriChanged);
    connect(m_syncChannel, &machinetalk::RpcClient::stateChanged,
            this, &SyncClient::syncChannelStateChanged);
    connect(m_syncChannel, &machinetalk::RpcClient::socketMessageReceived,
            this, &SyncClient::processSyncChannelMessage);
    // initialize sub channel
    m_subChannel = new machinetalk::Subscribe(this);
    m_subChannel->setDebugName(m_debugName + " - sub");
    connect(m_subChannel, &machinetalk::Subscribe::socketUriChanged,
            this, &SyncClient::subUriChanged);
    connect(m_subChannel, &machinetalk::Subscribe::stateChanged,
            this, &SyncClient::subChannelStateChanged);
    connect(m_subChannel, &machinetalk::Subscribe::socketMessageReceived,
            this, &SyncClient::processSubChannelMessage);
    // initialize pub channel
    m_pubChannel = new machinetalk::Publish(this);
    m_pubChannel->setDebugName(m_debugName + " - pub");
    connect(m_pubChannel, &machinetalk::Publish::socketUriChanged,
            this, &SyncClient::pubUriChanged);

    connect(m_syncChannel, &machinetalk::RpcClient::heartbeatIntervalChanged,
            this, &SyncClient::syncHeartbeatIntervalChanged);

    connect(m_subChannel, &machinetalk::Subscribe::heartbeatIntervalChanged,
            this, &SyncClient::subHeartbeatIntervalChanged);

    connect(m_pubChannel, &machinetalk::Publish::heartbeatIntervalChanged,
            this, &SyncClient::pubHeartbeatIntervalChanged);

    m_fsm = new QStateMachine(this);
    QState *downState = new QState(m_fsm);
    connect(downState, &QState::entered, this, &SyncClient::fsmDownEntered, Qt::QueuedConnection);
    QState *tryingState = new QState(m_fsm);
    connect(tryingState, &QState::entered, this, &SyncClient::fsmTryingEntered, Qt::QueuedConnection);
    QState *syncingState = new QState(m_fsm);
    connect(syncingState, &QState::entered, this, &SyncClient::fsmSyncingEntered, Qt::QueuedConnection);
    QState *syncedState = new QState(m_fsm);
    connect(syncedState, &QState::entered, this, &SyncClient::fsmSyncedEntered, Qt::QueuedConnection);
    m_fsm->setInitialState(downState);
    m_fsm->start();

    connect(this, &SyncClient::fsmDownStart,
            this, &SyncClient::fsmDownStartQueued, Qt::QueuedConnection);
    downState->addTransition(this, &SyncClient::fsmDownStartQueued, tryingState);
    connect(this, &SyncClient::fsmTryingSyncStateUp,
            this, &SyncClient::fsmTryingSyncStateUpQueued, Qt::QueuedConnection);
    tryingState->addTransition(this, &SyncClient::fsmTryingSyncStateUpQueued, syncingState);
    connect(this, &SyncClient::fsmTryingStop,
            this, &SyncClient::fsmTryingStopQueued, Qt::QueuedConnection);
    tryingState->addTransition(this, &SyncClient::fsmTryingStopQueued, downState);
    connect(this, &SyncClient::fsmSyncingSyncStateTrying,
            this, &SyncClient::fsmSyncingSyncStateTryingQueued, Qt::QueuedConnection);
    syncingState->addTransition(this, &SyncClient::fsmSyncingSyncStateTryingQueued, tryingState);
    connect(this, &SyncClient::fsmSyncingSubStateUp,
            this, &SyncClient::fsmSyncingSubStateUpQueued, Qt::QueuedConnection);
    syncingState->addTransition(this, &SyncClient::fsmSyncingSubStateUpQueued, syncedState);
    connect(this, &SyncClient::fsmSyncingStop,
            this, &SyncClient::fsmSyncingStopQueued, Qt::QueuedConnection);
    syncingState->addTransition(this, &SyncClient::fsmSyncingStopQueued, downState);
    connect(this, &SyncClient::fsmSyncedSubStateTrying,
            this, &SyncClient::fsmSyncedSubStateTryingQueued, Qt::QueuedConnection);
    syncedState->addTransition(this, &SyncClient::fsmSyncedSubStateTryingQueued, syncingState);
    connect(this, &SyncClient::fsmSyncedSyncStateTrying,
            this, &SyncClient::fsmSyncedSyncStateTryingQueued, Qt::QueuedConnection);
    syncedState->addTransition(this, &SyncClient::fsmSyncedSyncStateTryingQueued, tryingState);
    connect(this, &SyncClient::fsmSyncedStop,
            this, &SyncClient::fsmSyncedStopQueued, Qt::QueuedConnection);
    syncedState->addTransition(this, &SyncClient::fsmSyncedStopQueued, downState);

    connect(this, &SyncClient::fsmDownStart,
            this, &SyncClient::fsmDownStartEvent, Qt::QueuedConnection);
    connect(this, &SyncClient::fsmTryingSyncStateUp,
            this, &SyncClient::fsmTryingSyncStateUpEvent, Qt::QueuedConnection);
    connect(this, &SyncClient::fsmTryingStop,
            this, &SyncClient::fsmTryingStopEvent, Qt::QueuedConnection);
    connect(this, &SyncClient::fsmSyncingSyncStateTrying,
            this, &SyncClient::fsmSyncingSyncStateTryingEvent, Qt::QueuedConnection);
    connect(this, &SyncClient::fsmSyncingSubStateUp,
            this, &SyncClient::fsmSyncingSubStateUpEvent, Qt::QueuedConnection);
    connect(this, &SyncClient::fsmSyncingStop,
            this, &SyncClient::fsmSyncingStopEvent, Qt::QueuedConnection);
    connect(this, &SyncClient::fsmSyncedSubStateTrying,
            this, &SyncClient::fsmSyncedSubStateTryingEvent, Qt::QueuedConnection);
    connect(this, &SyncClient::fsmSyncedSyncStateTrying,
            this, &SyncClient::fsmSyncedSyncStateTryingEvent, Qt::QueuedConnection);
    connect(this, &SyncClient::fsmSyncedStop,
            this, &SyncClient::fsmSyncedStopEvent, Qt::QueuedConnection);

     connect(this, &SyncClient::startSignal,
             this, &SyncClient::startSlot, Qt::QueuedConnection);
     connect(this, &SyncClient::stopSignal,
             this, &SyncClient::stopSlot, Qt::QueuedConnection);
}

SyncClient::~SyncClient()
{
}

/** Add a topic that should be subscribed **/
void SyncClient::addSubTopic(const QString &name)
{
    m_subChannel->addSocketTopic(name);
}

/** Removes a topic from the list of topics that should be subscribed **/
void SyncClient::removeSubTopic(const QString &name)
{
    m_subChannel->removeSocketTopic(name);
}

/** Clears the the topics that should be subscribed **/
void SyncClient::clearSubTopics()
{
    m_subChannel->clearSocketTopics();
}

void SyncClient::startSyncChannel()
{
    m_syncChannel->setReady(true);
}

void SyncClient::stopSyncChannel()
{
    m_syncChannel->setReady(false);
}

void SyncClient::startSubChannel()
{
    m_subChannel->setReady(true);
}

void SyncClient::stopSubChannel()
{
    m_subChannel->setReady(false);
}

void SyncClient::startPubChannel()
{
    m_pubChannel->setReady(true);
}

void SyncClient::stopPubChannel()
{
    m_pubChannel->setReady(false);
}

/** Processes all message received on sync */
void SyncClient::processSyncChannelMessage(const pb::Container &rx)
{

    emit syncMessageReceived(rx);
}

/** Processes all message received on sub */
void SyncClient::processSubChannelMessage(const QByteArray &topic, const pb::Container &rx)
{

    emit subMessageReceived(topic, rx);
}

void SyncClient::sendSyncMessage(pb::ContainerType type, pb::Container &tx)
{
    m_syncChannel->sendSocketMessage(type, tx);
}

void SyncClient::sendPubMessage(pb::ContainerType type, pb::Container &tx)
{
    m_pubChannel->sendSocketMessage(type, tx);
}

void SyncClient::sendSync()
{
    pb::Container &tx = m_syncTx;
    sendSyncMessage(pb::MT_SYNC, tx);
}

void SyncClient::sendIncrementalUpdate(pb::Container &tx)
{
    sendPubMessage(pb::MT_INCREMENTAL_UPDATE, tx);
}

void SyncClient::fsmDownEntered()
{
    if (m_previousState != Down)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State DOWN");
#endif
        m_previousState = Down;
        emit stateChanged(m_state);
    }
}

void SyncClient::fsmDownStartEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event START");
#endif

    m_state = Trying;
    startSyncChannel();
    startPubChannel();
}

void SyncClient::fsmTryingEntered()
{
    if (m_previousState != Trying)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State TRYING");
#endif
        m_previousState = Trying;
        emit stateChanged(m_state);
    }
}

void SyncClient::fsmTryingSyncStateUpEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event SYNC STATE UP");
#endif

    m_state = Syncing;
    sendSync();
    startSubChannel();
}

void SyncClient::fsmTryingStopEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event STOP");
#endif

    m_state = Down;
    stopSyncChannel();
    stopSubChannel();
    stopPubChannel();
}

void SyncClient::fsmSyncingEntered()
{
    if (m_previousState != Syncing)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State SYNCING");
#endif
        m_previousState = Syncing;
        emit stateChanged(m_state);
    }
}

void SyncClient::fsmSyncingSyncStateTryingEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event SYNC STATE TRYING");
#endif

    m_state = Trying;
    stopSubChannel();
}

void SyncClient::fsmSyncingSubStateUpEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event SUB STATE UP");
#endif

    m_state = Synced;
    synced();
}

void SyncClient::fsmSyncingStopEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event STOP");
#endif

    m_state = Down;
    stopSyncChannel();
    stopSubChannel();
    stopPubChannel();
}

void SyncClient::fsmSyncedEntered()
{
    if (m_previousState != Synced)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State SYNCED");
#endif
        m_previousState = Synced;
        emit stateChanged(m_state);
    }
}

void SyncClient::fsmSyncedSubStateTryingEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event SUB STATE TRYING");
#endif

    m_state = Syncing;
    sendSync();
}

void SyncClient::fsmSyncedSyncStateTryingEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event SYNC STATE TRYING");
#endif

    m_state = Trying;
    stopSubChannel();
}

void SyncClient::fsmSyncedStopEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event STOP");
#endif

    m_state = Down;
    stopSyncChannel();
    stopSubChannel();
    stopPubChannel();
}

void SyncClient::syncChannelStateChanged(machinetalk::RpcClient::State state)
{

    if (state == machinetalk::RpcClient::Trying)
    {
        if (m_state == Syncing)
        {
            emit fsmSyncingSyncStateTrying();
        }
        if (m_state == Synced)
        {
            emit fsmSyncedSyncStateTrying();
        }
    }

    if (state == machinetalk::RpcClient::Up)
    {
        if (m_state == Trying)
        {
            emit fsmTryingSyncStateUp();
        }
    }
}

void SyncClient::subChannelStateChanged(machinetalk::Subscribe::State state)
{

    if (state == machinetalk::Subscribe::Trying)
    {
        if (m_state == Synced)
        {
            emit fsmSyncedSubStateTrying();
        }
    }

    if (state == machinetalk::Subscribe::Up)
    {
        if (m_state == Syncing)
        {
            emit fsmSyncingSubStateUp();
        }
    }
}

/** start trigger */
void SyncClient::start()
{
    emit startSignal(QPrivateSignal());
}

/** start queued trigger function */
void SyncClient::startSlot()
{
    if (m_state == Down) {
        emit fsmDownStart();
    }
}

/** stop trigger */
void SyncClient::stop()
{
    emit stopSignal(QPrivateSignal());
}

/** stop queued trigger function */
void SyncClient::stopSlot()
{
    if (m_state == Trying) {
        emit fsmTryingStop();
    }
    if (m_state == Syncing) {
        emit fsmSyncingStop();
    }
    if (m_state == Synced) {
        emit fsmSyncedStop();
    }
}
}; // namespace machinetalk
