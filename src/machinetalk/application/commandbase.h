/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#ifndef COMMAND_BASE_H
#define COMMAND_BASE_H
#include <QObject>
#include <QStateMachine>
#include <QQmlParserStatus>
#include <nzmqt/nzmqt.hpp>
#include <machinetalk/protobuf/message.pb.h>
#include <google/protobuf/text_format.h>
#include <machinetalk/rpcclient.h>

namespace application {

class CommandBase : public QObject
,public QQmlParserStatus
{
    Q_OBJECT
    Q_INTERFACES(QQmlParserStatus)
    Q_PROPERTY(bool ready READ ready WRITE setReady NOTIFY readyChanged)
    Q_PROPERTY(QString commandUri READ commandUri WRITE setCommandUri NOTIFY commandUriChanged)
    Q_PROPERTY(QString debugName READ debugName WRITE setDebugName NOTIFY debugNameChanged)
    Q_PROPERTY(State connectionState READ state NOTIFY stateChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
    Q_PROPERTY(int commandHeartbeatInterval READ commandHeartbeatInterval WRITE setCommandHeartbeatInterval NOTIFY commandHeartbeatIntervalChanged)
    Q_ENUMS(State)

public:
    explicit CommandBase(QObject *parent = 0);
    ~CommandBase();

    enum State {
        Down = 0,
        Trying = 1,
        Up = 2,
    };

    void classBegin() {}
    /** componentComplete is executed when the QML component is fully loaded */
    void componentComplete()
    {
        m_componentCompleted = true;

        if (m_ready == true)    // the component was set to ready before it was completed
        {
            start();
        }
    }

    QString commandUri() const
    {
        return m_commandChannel->socketUri();
    }

    QString debugName() const
    {
        return m_debugName;
    }

    State state() const
    {
        return m_state;
    }

    QString errorString() const
    {
        return m_errorString;
    }

    int commandHeartbeatInterval() const
    {
        return m_commandChannel->heartbeatInterval();
    }

    bool ready() const
    {
        return m_ready;
    }

public slots:

    void setCommandUri(QString uri)
    {
        m_commandChannel->setSocketUri(uri);
    }

    void setDebugName(QString debugName)
    {
        if (m_debugName == debugName)
            return;

        m_debugName = debugName;
        emit debugNameChanged(debugName);
    }

    void setCommandHeartbeatInterval(int interval)
    {
        m_commandChannel->setHeartbeatInterval(interval);
    }

    void setReady(bool ready)
    {
        if (m_ready == ready)
            return;

        m_ready = ready;
        emit readyChanged(ready);

        if (m_componentCompleted == false)
        {
            return;
        }

        if (m_ready)
        {
            start();
        }
        else
        {
            stop();
        }
    }


    void sendCommandMessage(pb::ContainerType type, pb::Container &tx);
    void sendEmcTaskAbort(pb::Container &tx);
    void sendEmcTaskPlanRun(pb::Container &tx);
    void sendEmcTaskPlanPause(pb::Container &tx);
    void sendEmcTaskPlanStep(pb::Container &tx);
    void sendEmcTaskPlanResume(pb::Container &tx);
    void sendEmcSetDebug(pb::Container &tx);
    void sendEmcCoolantFloodOn(pb::Container &tx);
    void sendEmcCoolantFloodOff(pb::Container &tx);
    void sendEmcAxisHome(pb::Container &tx);
    void sendEmcAxisJog(pb::Container &tx);
    void sendEmcAxisAbort(pb::Container &tx);
    void sendEmcAxisIncrJog(pb::Container &tx);
    void sendEmcToolLoadToolTable(pb::Container &tx);
    void sendEmcToolUpdateToolTable(pb::Container &tx);
    void sendEmcTaskPlanExecute(pb::Container &tx);
    void sendEmcCoolantMistOn(pb::Container &tx);
    void sendEmcCoolantMistOff(pb::Container &tx);
    void sendEmcTaskPlanInit(pb::Container &tx);
    void sendEmcTaskPlanOpen(pb::Container &tx);
    void sendEmcTaskPlanSetOptionalStop(pb::Container &tx);
    void sendEmcTaskPlanSetBlockDelete(pb::Container &tx);
    void sendEmcTaskSetMode(pb::Container &tx);
    void sendEmcTaskSetState(pb::Container &tx);
    void sendEmcTrajSetSoEnable(pb::Container &tx);
    void sendEmcTrajSetFhEnable(pb::Container &tx);
    void sendEmcTrajSetFoEnable(pb::Container &tx);
    void sendEmcTrajSetMaxVelocity(pb::Container &tx);
    void sendEmcTrajSetMode(pb::Container &tx);
    void sendEmcTrajSetScale(pb::Container &tx);
    void sendEmcTrajSetRapidScale(pb::Container &tx);
    void sendEmcTrajSetSpindleScale(pb::Container &tx);
    void sendEmcTrajSetTeleopEnable(pb::Container &tx);
    void sendEmcTrajSetTeleopVector(pb::Container &tx);
    void sendEmcToolSetOffset(pb::Container &tx);
    void sendEmcAxisOverrideLimits(pb::Container &tx);
    void sendEmcSpindleConstant(pb::Container &tx);
    void sendEmcSpindleDecrease(pb::Container &tx);
    void sendEmcSpindleIncrease(pb::Container &tx);
    void sendEmcSpindleOff(pb::Container &tx);
    void sendEmcSpindleOn(pb::Container &tx);
    void sendEmcSpindleBrakeEngage(pb::Container &tx);
    void sendEmcSpindleBrakeRelease(pb::Container &tx);
    void sendEmcMotionSetAout(pb::Container &tx);
    void sendEmcMotionSetDout(pb::Container &tx);
    void sendEmcMotionAdaptive(pb::Container &tx);
    void sendEmcAxisSetMaxPositionLimit(pb::Container &tx);
    void sendEmcAxisSetMinPositionLimit(pb::Container &tx);
    void sendEmcAxisUnhome(pb::Container &tx);
    void sendShutdown(pb::Container &tx);

protected:
    void start(); // start trigger
    void stop(); // stop trigger

private:
    bool m_componentCompleted;
    bool m_ready;
    QString m_debugName;

    machinetalk::RpcClient *m_commandChannel;

    State         m_state;
    State         m_previousState;
    QStateMachine *m_fsm;
    QString       m_errorString;
    // more efficient to reuse a protobuf Messages
    pb::Container m_commandRx;
    pb::Container m_commandTx;

private slots:

    void startCommandChannel();
    void stopCommandChannel();
    void commandChannelStateChanged(machinetalk::RpcClient::State state);
    void processCommandChannelMessage(const pb::Container &rx);

    void fsmDownEntered();
    void fsmDownConnectEvent();
    void fsmTryingEntered();
    void fsmTryingCommandUpEvent();
    void fsmTryingDisconnectEvent();
    void fsmUpEntered();
    void fsmUpCommandTryingEvent();
    void fsmUpDisconnectEvent();

    virtual void setConnected() = 0;
    virtual void clearConnected() = 0;

signals:

    void commandUriChanged(QString uri);
    void commandMessageReceived(const pb::Container &rx);
    void debugNameChanged(QString debugName);
    void stateChanged(CommandBase::State state);
    void errorStringChanged(QString errorString);
    void commandHeartbeatIntervalChanged(int interval);
    void readyChanged(bool ready);
    // fsm
    void fsmDownConnect();
    void fsmDownConnectQueued();
    void fsmTryingCommandUp();
    void fsmTryingCommandUpQueued();
    void fsmTryingDisconnect();
    void fsmTryingDisconnectQueued();
    void fsmUpCommandTrying();
    void fsmUpCommandTryingQueued();
    void fsmUpDisconnect();
    void fsmUpDisconnectQueued();
};
}; // namespace application
#endif //COMMAND_BASE_H
