/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#include "launcherbase.h"
#include "debughelper.h"

#if defined(Q_OS_IOS)
namespace gpb = google_public::protobuf;
#else
namespace gpb = google::protobuf;
#endif

using namespace nzmqt;

namespace application {

/** Generic Launcher Base implementation */
LauncherBase::LauncherBase(QObject *parent) :
    QObject(parent),
    QQmlParserStatus(),
    m_componentCompleted(false),
    m_ready(false),
    m_debugName("Launcher Base"),
    m_launchercmdChannel(nullptr),
    m_launcherChannel(nullptr),
    m_state(Down),
    m_previousState(Down),
    m_fsm(nullptr),
    m_errorString("")
{
    // initialize launchercmd channel
    m_launchercmdChannel = new machinetalk::RpcClient(this);
    m_launchercmdChannel->setDebugName(m_debugName + " - launchercmd");
    connect(m_launchercmdChannel, &machinetalk::RpcClient::socketUriChanged,
            this, &LauncherBase::launchercmdUriChanged);
    connect(m_launchercmdChannel, &machinetalk::RpcClient::stateChanged,
            this, &LauncherBase::launchercmdChannelStateChanged);
    connect(m_launchercmdChannel, &machinetalk::RpcClient::socketMessageReceived,
            this, &LauncherBase::processLaunchercmdChannelMessage);
    // initialize launcher channel
    m_launcherChannel = new application::LauncherSubscribe(this);
    m_launcherChannel->setDebugName(m_debugName + " - launcher");
    connect(m_launcherChannel, &application::LauncherSubscribe::socketUriChanged,
            this, &LauncherBase::launcherUriChanged);
    connect(m_launcherChannel, &application::LauncherSubscribe::stateChanged,
            this, &LauncherBase::launcherChannelStateChanged);
    connect(m_launcherChannel, &application::LauncherSubscribe::socketMessageReceived,
            this, &LauncherBase::processLauncherChannelMessage);

    connect(m_launchercmdChannel, &machinetalk::RpcClient::heartbeatIntervalChanged,
            this, &LauncherBase::launchercmdHeartbeatIntervalChanged);

    connect(m_launcherChannel, &application::LauncherSubscribe::heartbeatIntervalChanged,
            this, &LauncherBase::launcherHeartbeatIntervalChanged);

    m_fsm = new QStateMachine(this);
    QState *downState = new QState(m_fsm);
    connect(downState, &QState::entered, this, &LauncherBase::fsmDownEntered, Qt::QueuedConnection);
    QState *tryingState = new QState(m_fsm);
    connect(tryingState, &QState::entered, this, &LauncherBase::fsmTryingEntered, Qt::QueuedConnection);
    QState *syncingState = new QState(m_fsm);
    connect(syncingState, &QState::entered, this, &LauncherBase::fsmSyncingEntered, Qt::QueuedConnection);
    QState *syncedState = new QState(m_fsm);
    connect(syncedState, &QState::entered, this, &LauncherBase::fsmSyncedEntered, Qt::QueuedConnection);
    connect(syncedState, &QState::entered, this, &LauncherBase::syncStatus, Qt::QueuedConnection);
    connect(syncedState, &QState::exited, this, &LauncherBase::unsyncStatus, Qt::QueuedConnection);
    m_fsm->setInitialState(downState);
    m_fsm->start();

    connect(this, &LauncherBase::fsmDownConnect,
            this, &LauncherBase::fsmDownConnectQueued, Qt::QueuedConnection);
    downState->addTransition(this, &LauncherBase::fsmDownConnectQueued, tryingState);
    connect(this, &LauncherBase::fsmTryingLaunchercmdUp,
            this, &LauncherBase::fsmTryingLaunchercmdUpQueued, Qt::QueuedConnection);
    tryingState->addTransition(this, &LauncherBase::fsmTryingLaunchercmdUpQueued, syncingState);
    connect(this, &LauncherBase::fsmTryingDisconnect,
            this, &LauncherBase::fsmTryingDisconnectQueued, Qt::QueuedConnection);
    tryingState->addTransition(this, &LauncherBase::fsmTryingDisconnectQueued, downState);
    connect(this, &LauncherBase::fsmSyncingLaunchercmdTrying,
            this, &LauncherBase::fsmSyncingLaunchercmdTryingQueued, Qt::QueuedConnection);
    syncingState->addTransition(this, &LauncherBase::fsmSyncingLaunchercmdTryingQueued, tryingState);
    connect(this, &LauncherBase::fsmSyncingLauncherUp,
            this, &LauncherBase::fsmSyncingLauncherUpQueued, Qt::QueuedConnection);
    syncingState->addTransition(this, &LauncherBase::fsmSyncingLauncherUpQueued, syncedState);
    connect(this, &LauncherBase::fsmSyncingDisconnect,
            this, &LauncherBase::fsmSyncingDisconnectQueued, Qt::QueuedConnection);
    syncingState->addTransition(this, &LauncherBase::fsmSyncingDisconnectQueued, downState);
    connect(this, &LauncherBase::fsmSyncedLauncherTrying,
            this, &LauncherBase::fsmSyncedLauncherTryingQueued, Qt::QueuedConnection);
    syncedState->addTransition(this, &LauncherBase::fsmSyncedLauncherTryingQueued, syncingState);
    connect(this, &LauncherBase::fsmSyncedLaunchercmdTrying,
            this, &LauncherBase::fsmSyncedLaunchercmdTryingQueued, Qt::QueuedConnection);
    syncedState->addTransition(this, &LauncherBase::fsmSyncedLaunchercmdTryingQueued, tryingState);
    connect(this, &LauncherBase::fsmSyncedDisconnect,
            this, &LauncherBase::fsmSyncedDisconnectQueued, Qt::QueuedConnection);
    syncedState->addTransition(this, &LauncherBase::fsmSyncedDisconnectQueued, downState);

    connect(this, &LauncherBase::fsmDownConnect,
            this, &LauncherBase::fsmDownConnectEvent, Qt::QueuedConnection);
    connect(this, &LauncherBase::fsmTryingLaunchercmdUp,
            this, &LauncherBase::fsmTryingLaunchercmdUpEvent, Qt::QueuedConnection);
    connect(this, &LauncherBase::fsmTryingDisconnect,
            this, &LauncherBase::fsmTryingDisconnectEvent, Qt::QueuedConnection);
    connect(this, &LauncherBase::fsmSyncingLaunchercmdTrying,
            this, &LauncherBase::fsmSyncingLaunchercmdTryingEvent, Qt::QueuedConnection);
    connect(this, &LauncherBase::fsmSyncingLauncherUp,
            this, &LauncherBase::fsmSyncingLauncherUpEvent, Qt::QueuedConnection);
    connect(this, &LauncherBase::fsmSyncingDisconnect,
            this, &LauncherBase::fsmSyncingDisconnectEvent, Qt::QueuedConnection);
    connect(this, &LauncherBase::fsmSyncedLauncherTrying,
            this, &LauncherBase::fsmSyncedLauncherTryingEvent, Qt::QueuedConnection);
    connect(this, &LauncherBase::fsmSyncedLaunchercmdTrying,
            this, &LauncherBase::fsmSyncedLaunchercmdTryingEvent, Qt::QueuedConnection);
    connect(this, &LauncherBase::fsmSyncedDisconnect,
            this, &LauncherBase::fsmSyncedDisconnectEvent, Qt::QueuedConnection);
}

LauncherBase::~LauncherBase()
{
}

/** Add a topic that should be subscribed **/
void LauncherBase::addLauncherTopic(const QString &name)
{
    m_launcherChannel->addSocketTopic(name);
}

/** Removes a topic from the list of topics that should be subscribed **/
void LauncherBase::removeLauncherTopic(const QString &name)
{
    m_launcherChannel->removeSocketTopic(name);
}

/** Clears the the topics that should be subscribed **/
void LauncherBase::clearLauncherTopics()
{
    m_launcherChannel->clearSocketTopics();
}

void LauncherBase::startLaunchercmdChannel()
{
    m_launchercmdChannel->setReady(true);
}

void LauncherBase::stopLaunchercmdChannel()
{
    m_launchercmdChannel->setReady(false);
}

void LauncherBase::startLauncherChannel()
{
    m_launcherChannel->setReady(true);
}

void LauncherBase::stopLauncherChannel()
{
    m_launcherChannel->setReady(false);
}

/** Processes all message received on launchercmd */
void LauncherBase::processLaunchercmdChannelMessage(const pb::Container &rx)
{

    // react to error message
    if (rx.type() == pb::MT_ERROR)
    {

        // update error string with note
        m_errorString = "";
        for (int i = 0; i < rx.note_size(); ++i)
        {
            m_errorString.append(QString::fromStdString(rx.note(i)) + "\n");
        }
        emit errorStringChanged(m_errorString);
    }

    emit launchercmdMessageReceived(rx);
}

/** Processes all message received on launcher */
void LauncherBase::processLauncherChannelMessage(const QByteArray &topic, const pb::Container &rx)
{

    // react to launcher full update message
    if (rx.type() == pb::MT_LAUNCHER_FULL_UPDATE)
    {
        launcherFullUpdateReceived(topic, rx);
    }

    // react to launcher incremental update message
    if (rx.type() == pb::MT_LAUNCHER_INCREMENTAL_UPDATE)
    {
        launcherIncrementalUpdateReceived(topic, rx);
    }

    emit launcherMessageReceived(topic, rx);
}

void LauncherBase::sendLaunchercmdMessage(pb::ContainerType type, pb::Container *tx)
{
    m_launchercmdChannel->sendSocketMessage(type, tx);
}

void LauncherBase::sendLauncherStart(pb::Container *tx)
{
    sendLaunchercmdMessage(pb::MT_LAUNCHER_START, tx);
}

void LauncherBase::sendLauncherKill(pb::Container *tx)
{
    sendLaunchercmdMessage(pb::MT_LAUNCHER_KILL, tx);
}

void LauncherBase::sendLauncherTerminate(pb::Container *tx)
{
    sendLaunchercmdMessage(pb::MT_LAUNCHER_TERMINATE, tx);
}

void LauncherBase::sendLauncherWriteStdin(pb::Container *tx)
{
    sendLaunchercmdMessage(pb::MT_LAUNCHER_WRITE_STDIN, tx);
}

void LauncherBase::sendLauncherCall(pb::Container *tx)
{
    sendLaunchercmdMessage(pb::MT_LAUNCHER_CALL, tx);
}

void LauncherBase::sendLauncherShutdown(pb::Container *tx)
{
    sendLaunchercmdMessage(pb::MT_LAUNCHER_SHUTDOWN, tx);
}

void LauncherBase::fsmDownEntered()
{
    if (m_previousState != Down)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State DOWN");
#endif
        m_previousState = Down;
        emit stateChanged(m_state);
    }
}

void LauncherBase::fsmDownConnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event CONNECT");
#endif

    m_state = Trying;
    startLaunchercmdChannel();
}

void LauncherBase::fsmTryingEntered()
{
    if (m_previousState != Trying)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State TRYING");
#endif
        m_previousState = Trying;
        emit stateChanged(m_state);
    }
}

void LauncherBase::fsmTryingLaunchercmdUpEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event LAUNCHERCMD UP");
#endif

    m_state = Syncing;
    startLauncherChannel();
}

void LauncherBase::fsmTryingDisconnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event DISCONNECT");
#endif

    m_state = Down;
    stopLaunchercmdChannel();
    stopLauncherChannel();
}

void LauncherBase::fsmSyncingEntered()
{
    if (m_previousState != Syncing)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State SYNCING");
#endif
        m_previousState = Syncing;
        emit stateChanged(m_state);
    }
}

void LauncherBase::fsmSyncingLaunchercmdTryingEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event LAUNCHERCMD TRYING");
#endif

    m_state = Trying;
    stopLauncherChannel();
}

void LauncherBase::fsmSyncingLauncherUpEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event LAUNCHER UP");
#endif

    m_state = Synced;
}

void LauncherBase::fsmSyncingDisconnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event DISCONNECT");
#endif

    m_state = Down;
    stopLaunchercmdChannel();
    stopLauncherChannel();
}

void LauncherBase::fsmSyncedEntered()
{
    if (m_previousState != Synced)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State SYNCED");
#endif
        m_previousState = Synced;
        emit stateChanged(m_state);
    }
}

void LauncherBase::fsmSyncedLauncherTryingEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event LAUNCHER TRYING");
#endif

    m_state = Syncing;
}

void LauncherBase::fsmSyncedLaunchercmdTryingEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event LAUNCHERCMD TRYING");
#endif

    m_state = Trying;
    stopLauncherChannel();
}

void LauncherBase::fsmSyncedDisconnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event DISCONNECT");
#endif

    m_state = Down;
    stopLaunchercmdChannel();
    stopLauncherChannel();
}

void LauncherBase::launchercmdChannelStateChanged(machinetalk::RpcClient::State state)
{

    if (state == machinetalk::RpcClient::Trying)
    {
        if (m_state == Syncing)
        {
            emit fsmSyncingLaunchercmdTrying();
        }
        if (m_state == Synced)
        {
            emit fsmSyncedLaunchercmdTrying();
        }
    }

    if (state == machinetalk::RpcClient::Up)
    {
        if (m_state == Trying)
        {
            emit fsmTryingLaunchercmdUp();
        }
    }
}

void LauncherBase::launcherChannelStateChanged(application::LauncherSubscribe::State state)
{

    if (state == application::LauncherSubscribe::Trying)
    {
        if (m_state == Synced)
        {
            emit fsmSyncedLauncherTrying();
        }
    }

    if (state == application::LauncherSubscribe::Up)
    {
        if (m_state == Syncing)
        {
            emit fsmSyncingLauncherUp();
        }
    }
}

/** start trigger */
void LauncherBase::start()
{
    if (m_state == Down) {
        emit fsmDownConnect();
    }
}

/** stop trigger */
void LauncherBase::stop()
{
    if (m_state == Trying) {
        emit fsmTryingDisconnect();
    }
    if (m_state == Syncing) {
        emit fsmSyncingDisconnect();
    }
    if (m_state == Synced) {
        emit fsmSyncedDisconnect();
    }
}
}; // namespace application
