/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#include "commandbase.h"
#include "debughelper.h"

#if defined(Q_OS_IOS)
namespace gpb = google_public::protobuf;
#else
namespace gpb = google::protobuf;
#endif

using namespace nzmqt;

namespace application {

/** Generic Command Base implementation */
CommandBase::CommandBase(QObject *parent) :
    QObject(parent),
    QQmlParserStatus(),
    m_componentCompleted(false),
    m_ready(false),
    m_debugName("Command Base"),
    m_commandChannel(nullptr),
    m_state(Down),
    m_previousState(Down),
    m_fsm(nullptr),
    m_errorString("")
{
    // initialize command channel
    m_commandChannel = new machinetalk::RpcClient(this);
    m_commandChannel->setDebugName(m_debugName + " - command");
    connect(m_commandChannel, &machinetalk::RpcClient::socketUriChanged,
            this, &CommandBase::commandUriChanged);
    connect(m_commandChannel, &machinetalk::RpcClient::stateChanged,
            this, &CommandBase::commandChannelStateChanged);
    connect(m_commandChannel, &machinetalk::RpcClient::socketMessageReceived,
            this, &CommandBase::processCommandChannelMessage, Qt::QueuedConnection);

    connect(m_commandChannel, &machinetalk::RpcClient::heartbeatIntervalChanged,
            this, &CommandBase::commandHeartbeatIntervalChanged);

    m_fsm = new QStateMachine(this);
    QState *downState = new QState(m_fsm);
    connect(downState, &QState::entered, this, &CommandBase::fsmDownEntered, Qt::QueuedConnection);
    QState *tryingState = new QState(m_fsm);
    connect(tryingState, &QState::entered, this, &CommandBase::fsmTryingEntered, Qt::QueuedConnection);
    QState *upState = new QState(m_fsm);
    connect(upState, &QState::entered, this, &CommandBase::fsmUpEntered, Qt::QueuedConnection);
    connect(upState, &QState::entered, this, &CommandBase::setConnected, Qt::QueuedConnection);
    connect(upState, &QState::exited, this, &CommandBase::clearConnected, Qt::QueuedConnection);
    m_fsm->setInitialState(downState);
    m_fsm->start();

    connect(this, &CommandBase::fsmDownConnect,
            this, &CommandBase::fsmDownConnectQueued, Qt::QueuedConnection);
    downState->addTransition(this, &CommandBase::fsmDownConnectQueued, tryingState);
    connect(this, &CommandBase::fsmTryingCommandUp,
            this, &CommandBase::fsmTryingCommandUpQueued, Qt::QueuedConnection);
    tryingState->addTransition(this, &CommandBase::fsmTryingCommandUpQueued, upState);
    connect(this, &CommandBase::fsmTryingDisconnect,
            this, &CommandBase::fsmTryingDisconnectQueued, Qt::QueuedConnection);
    tryingState->addTransition(this, &CommandBase::fsmTryingDisconnectQueued, downState);
    connect(this, &CommandBase::fsmUpCommandTrying,
            this, &CommandBase::fsmUpCommandTryingQueued, Qt::QueuedConnection);
    upState->addTransition(this, &CommandBase::fsmUpCommandTryingQueued, tryingState);
    connect(this, &CommandBase::fsmUpDisconnect,
            this, &CommandBase::fsmUpDisconnectQueued, Qt::QueuedConnection);
    upState->addTransition(this, &CommandBase::fsmUpDisconnectQueued, downState);

    connect(this, &CommandBase::fsmDownConnect,
            this, &CommandBase::fsmDownConnectEvent, Qt::QueuedConnection);
    connect(this, &CommandBase::fsmTryingCommandUp,
            this, &CommandBase::fsmTryingCommandUpEvent, Qt::QueuedConnection);
    connect(this, &CommandBase::fsmTryingDisconnect,
            this, &CommandBase::fsmTryingDisconnectEvent, Qt::QueuedConnection);
    connect(this, &CommandBase::fsmUpCommandTrying,
            this, &CommandBase::fsmUpCommandTryingEvent, Qt::QueuedConnection);
    connect(this, &CommandBase::fsmUpDisconnect,
            this, &CommandBase::fsmUpDisconnectEvent, Qt::QueuedConnection);
}

CommandBase::~CommandBase()
{
}

void CommandBase::startCommandChannel()
{
    m_commandChannel->setReady(true);
}

void CommandBase::stopCommandChannel()
{
    m_commandChannel->setReady(false);
}

/** Processes all message received on command */
void CommandBase::processCommandChannelMessage(pb::Container *rx)
{

    // react to error message
    if (rx->type() == pb::MT_ERROR)
    {

        // update error string with note
        m_errorString = "";
        for (int i = 0; i < rx->note_size(); ++i)
        {
            m_errorString.append(QString::fromStdString(rx->note(i)) + "\n");
        }
        emit errorStringChanged(m_errorString);
    }

    emit commandMessageReceived(rx);
}

void CommandBase::sendCommandMessage(pb::ContainerType type, pb::Container *tx)
{
    m_commandChannel->sendSocketMessage(type, tx);
}

void CommandBase::sendEmcTaskAbort(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_ABORT, tx);
}

void CommandBase::sendEmcTaskPlanRun(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_PLAN_RUN, tx);
}

void CommandBase::sendEmcTaskPlanPause(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_PLAN_PAUSE, tx);
}

void CommandBase::sendEmcTaskPlanStep(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_PLAN_STEP, tx);
}

void CommandBase::sendEmcTaskPlanResume(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_PLAN_RESUME, tx);
}

void CommandBase::sendEmcSetDebug(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_SET_DEBUG, tx);
}

void CommandBase::sendEmcCoolantFloodOn(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_COOLANT_FLOOD_ON, tx);
}

void CommandBase::sendEmcCoolantFloodOff(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_COOLANT_FLOOD_OFF, tx);
}

void CommandBase::sendEmcAxisHome(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_AXIS_HOME, tx);
}

void CommandBase::sendEmcAxisJog(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_AXIS_JOG, tx);
}

void CommandBase::sendEmcAxisAbort(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_AXIS_ABORT, tx);
}

void CommandBase::sendEmcAxisIncrJog(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_AXIS_INCR_JOG, tx);
}

void CommandBase::sendEmcToolLoadToolTable(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TOOL_LOAD_TOOL_TABLE, tx);
}

void CommandBase::sendEmcToolUpdateToolTable(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TOOL_UPDATE_TOOL_TABLE, tx);
}

void CommandBase::sendEmcTaskPlanExecute(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_PLAN_EXECUTE, tx);
}

void CommandBase::sendEmcCoolantMistOn(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_COOLANT_MIST_ON, tx);
}

void CommandBase::sendEmcCoolantMistOff(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_COOLANT_MIST_OFF, tx);
}

void CommandBase::sendEmcTaskPlanInit(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_PLAN_INIT, tx);
}

void CommandBase::sendEmcTaskPlanOpen(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_PLAN_OPEN, tx);
}

void CommandBase::sendEmcTaskPlanSetOptionalStop(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_PLAN_SET_OPTIONAL_STOP, tx);
}

void CommandBase::sendEmcTaskPlanSetBlockDelete(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_PLAN_SET_BLOCK_DELETE, tx);
}

void CommandBase::sendEmcTaskSetMode(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_SET_MODE, tx);
}

void CommandBase::sendEmcTaskSetState(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TASK_SET_STATE, tx);
}

void CommandBase::sendEmcTrajSetSoEnable(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_SO_ENABLE, tx);
}

void CommandBase::sendEmcTrajSetFhEnable(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_FH_ENABLE, tx);
}

void CommandBase::sendEmcTrajSetFoEnable(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_FO_ENABLE, tx);
}

void CommandBase::sendEmcTrajSetMaxVelocity(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_MAX_VELOCITY, tx);
}

void CommandBase::sendEmcTrajSetMode(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_MODE, tx);
}

void CommandBase::sendEmcTrajSetScale(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_SCALE, tx);
}

void CommandBase::sendEmcTrajSetRapidScale(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_RAPID_SCALE, tx);
}

void CommandBase::sendEmcTrajSetSpindleScale(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_SPINDLE_SCALE, tx);
}

void CommandBase::sendEmcTrajSetTeleopEnable(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_TELEOP_ENABLE, tx);
}

void CommandBase::sendEmcTrajSetTeleopVector(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TRAJ_SET_TELEOP_VECTOR, tx);
}

void CommandBase::sendEmcToolSetOffset(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_TOOL_SET_OFFSET, tx);
}

void CommandBase::sendEmcAxisOverrideLimits(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_AXIS_OVERRIDE_LIMITS, tx);
}

void CommandBase::sendEmcSpindleConstant(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_SPINDLE_CONSTANT, tx);
}

void CommandBase::sendEmcSpindleDecrease(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_SPINDLE_DECREASE, tx);
}

void CommandBase::sendEmcSpindleIncrease(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_SPINDLE_INCREASE, tx);
}

void CommandBase::sendEmcSpindleOff(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_SPINDLE_OFF, tx);
}

void CommandBase::sendEmcSpindleOn(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_SPINDLE_ON, tx);
}

void CommandBase::sendEmcSpindleBrakeEngage(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_SPINDLE_BRAKE_ENGAGE, tx);
}

void CommandBase::sendEmcSpindleBrakeRelease(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_SPINDLE_BRAKE_RELEASE, tx);
}

void CommandBase::sendEmcMotionSetAout(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_MOTION_SET_AOUT, tx);
}

void CommandBase::sendEmcMotionSetDout(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_MOTION_SET_DOUT, tx);
}

void CommandBase::sendEmcMotionAdaptive(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_MOTION_ADAPTIVE, tx);
}

void CommandBase::sendEmcAxisSetMaxPositionLimit(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_AXIS_SET_MAX_POSITION_LIMIT, tx);
}

void CommandBase::sendEmcAxisSetMinPositionLimit(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_AXIS_SET_MIN_POSITION_LIMIT, tx);
}

void CommandBase::sendEmcAxisUnhome(pb::Container *tx)
{
    sendCommandMessage(pb::MT_EMC_AXIS_UNHOME, tx);
}

void CommandBase::sendShutdown(pb::Container *tx)
{
    sendCommandMessage(pb::MT_SHUTDOWN, tx);
}

void CommandBase::fsmDownEntered()
{
    if (m_previousState != Down)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State DOWN");
#endif
        m_previousState = Down;
        emit stateChanged(m_state);
    }
}

void CommandBase::fsmDownConnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event CONNECT");
#endif

    m_state = Trying;
    startCommandChannel();
}

void CommandBase::fsmTryingEntered()
{
    if (m_previousState != Trying)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State TRYING");
#endif
        m_previousState = Trying;
        emit stateChanged(m_state);
    }
}

void CommandBase::fsmTryingCommandUpEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event COMMAND UP");
#endif

    m_state = Up;
}

void CommandBase::fsmTryingDisconnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event DISCONNECT");
#endif

    m_state = Down;
    stopCommandChannel();
    clearConnected();
}

void CommandBase::fsmUpEntered()
{
    if (m_previousState != Up)
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State UP");
#endif
        m_previousState = Up;
        emit stateChanged(m_state);
    }
}

void CommandBase::fsmUpCommandTryingEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event COMMAND TRYING");
#endif

    m_state = Trying;
}

void CommandBase::fsmUpDisconnectEvent()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "Event DISCONNECT");
#endif

    m_state = Down;
    stopCommandChannel();
    clearConnected();
}

void CommandBase::commandChannelStateChanged(machinetalk::RpcClient::State state)
{

    if (state == machinetalk::RpcClient::Trying)
    {
        if (m_state == Up)
        {
            emit fsmUpCommandTrying();
        }
    }

    if (state == machinetalk::RpcClient::Up)
    {
        if (m_state == Trying)
        {
            emit fsmTryingCommandUp();
        }
    }
}

/** start trigger */
void CommandBase::start()
{
    if (m_state == Down) {
        emit fsmDownConnect();
    }
}

/** stop trigger */
void CommandBase::stop()
{
    if (m_state == Trying) {
        emit fsmTryingDisconnect();
    }
    if (m_state == Up) {
        emit fsmUpDisconnect();
    }
}
}; // namespace application
