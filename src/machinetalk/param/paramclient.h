/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#ifndef PARAM_CLIENT_H
#define PARAM_CLIENT_H
#include <QObject>
#include <QStateMachine>
#include <QQmlParserStatus>
#include <nzmqt/nzmqt.hpp>
#include <machinetalk/protobuf/message.pb.h>
#include <google/protobuf/text_format.h>
#include <machinetalk/rpcclient.h>
#include <machinetalk/subscribe.h>

namespace param {

class ParamClient : public QObject
,public QQmlParserStatus
{
    Q_OBJECT
    Q_INTERFACES(QQmlParserStatus)
    Q_PROPERTY(bool ready READ ready WRITE setReady NOTIFY readyChanged)
    Q_PROPERTY(QString paramcmdUri READ paramcmdUri WRITE setParamcmdUri NOTIFY paramcmdUriChanged)
    Q_PROPERTY(QString paramUri READ paramUri WRITE setParamUri NOTIFY paramUriChanged)
    Q_PROPERTY(QString debugName READ debugName WRITE setDebugName NOTIFY debugNameChanged)
    Q_PROPERTY(State connectionState READ state NOTIFY stateChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
    Q_PROPERTY(int paramcmdHeartbeatInterval READ paramcmdHeartbeatInterval WRITE setParamcmdHeartbeatInterval NOTIFY paramcmdHeartbeatIntervalChanged)
    Q_PROPERTY(int paramHeartbeatInterval READ paramHeartbeatInterval WRITE setParamHeartbeatInterval NOTIFY paramHeartbeatIntervalChanged)
    Q_ENUMS(State)

public:
    explicit ParamClient(QObject *parent = 0);
    ~ParamClient();

    enum State {
        Down = 0,
        Connecting = 1,
        Syncing = 2,
        Trying = 3,
        Up = 4,
    };

    void classBegin() {}
    /** componentComplete is executed when the QML component is fully loaded */
    void componentComplete()
    {
        m_componentCompleted = true;

        if (m_ready == true)    // the component was set to ready before it was completed
        {
            start();
        }
    }

    QString paramcmdUri() const
    {
        return m_paramcmdChannel->socketUri();
    }

    QString paramUri() const
    {
        return m_paramChannel->socketUri();
    }

    QString debugName() const
    {
        return m_debugName;
    }

    State state() const
    {
        return m_state;
    }

    QString errorString() const
    {
        return m_errorString;
    }

    int paramcmdHeartbeatInterval() const
    {
        return m_paramcmdChannel->heartbeatInterval();
    }

    int paramHeartbeatInterval() const
    {
        return m_paramChannel->heartbeatInterval();
    }

    bool ready() const
    {
        return m_ready;
    }

public slots:

    void setParamcmdUri(QString uri)
    {
        m_paramcmdChannel->setSocketUri(uri);
    }

    void setParamUri(QString uri)
    {
        m_paramChannel->setSocketUri(uri);
    }

    void setDebugName(QString debugName)
    {
        if (m_debugName == debugName)
            return;

        m_debugName = debugName;
        emit debugNameChanged(debugName);
    }

    void setParamcmdHeartbeatInterval(int interval)
    {
        m_paramcmdChannel->setHeartbeatInterval(interval);
    }

    void setParamHeartbeatInterval(int interval)
    {
        m_paramChannel->setHeartbeatInterval(interval);
    }

    void setReady(bool ready)
    {
        if (m_ready == ready)
            return;

        m_ready = ready;
        emit readyChanged(ready);

        if (m_componentCompleted == false)
        {
            return;
        }

        if (m_ready)
        {
            start();
        }
        else
        {
            stop();
        }
    }


    void sendParamcmdMessage(pb::ContainerType type, pb::Container &tx);
    void sendIncrementalUpdate(pb::Container &tx);
    void addParamTopic(const QString &name);
    void removeParamTopic(const QString &name);
    void clearParamTopics();

protected:
    void start(); // start trigger
    void stop(); // stop trigger

private:
    bool m_componentCompleted;
    bool m_ready;
    QString m_debugName;

    machinetalk::RpcClient *m_paramcmdChannel;
    QSet<QString> m_paramTopics;    // the topics we are interested in
    machinetalk::Subscribe *m_paramChannel;

    State         m_state;
    State         m_previousState;
    QStateMachine *m_fsm;
    QString       m_errorString;
    // more efficient to reuse a protobuf Messages
    pb::Container m_paramcmdTx;
    pb::Container m_paramRx;

private slots:

    void startParamcmdChannel();
    void stopParamcmdChannel();
    void paramcmdChannelStateChanged(machinetalk::RpcClient::State state);

    void startParamChannel();
    void stopParamChannel();
    void paramChannelStateChanged(machinetalk::Subscribe::State state);
    void processParamChannelMessage(const QByteArray &topic, const pb::Container &rx);

    void fsmDownEntered();
    void fsmDownConnectEvent();
    void fsmConnectingEntered();
    void fsmConnectingParamcmdUpEvent();
    void fsmConnectingParamUpEvent();
    void fsmConnectingDisconnectEvent();
    void fsmSyncingEntered();
    void fsmSyncingParamUpEvent();
    void fsmSyncingParamcmdTryingEvent();
    void fsmSyncingDisconnectEvent();
    void fsmTryingEntered();
    void fsmTryingParamcmdUpEvent();
    void fsmTryingParamTryingEvent();
    void fsmTryingDisconnectEvent();
    void fsmUpEntered();
    void fsmUpParamcmdTryingEvent();
    void fsmUpParamTryingEvent();
    void fsmUpDisconnectEvent();

    virtual void fullUpdateReceived(const QByteArray &topic, const pb::Container &rx) = 0;
    virtual void incrementalUpdateReceived(const QByteArray &topic, const pb::Container &rx) = 0;
    virtual void removeKeys() = 0;
    virtual void unsyncKeys() = 0;
    virtual void setSynced() = 0;
    virtual void clearSynced() = 0;
    void startSlot(); // start trigger
    void stopSlot(); // stop trigger

signals:
    void paramcmdUriChanged(QString uri);
    void paramUriChanged(QString uri);
    void paramMessageReceived(const QByteArray &topic, const pb::Container &rx);
    void debugNameChanged(QString debugName);
    void stateChanged(ParamClient::State state);
    void errorStringChanged(QString errorString);
    void paramcmdHeartbeatIntervalChanged(int interval);
    void paramHeartbeatIntervalChanged(int interval);
    void readyChanged(bool ready);
    // fsm
    void fsmDownConnect();
    void fsmDownConnectQueued();
    void fsmConnectingParamcmdUp();
    void fsmConnectingParamcmdUpQueued();
    void fsmConnectingParamUp();
    void fsmConnectingParamUpQueued();
    void fsmConnectingDisconnect();
    void fsmConnectingDisconnectQueued();
    void fsmSyncingParamUp();
    void fsmSyncingParamUpQueued();
    void fsmSyncingParamcmdTrying();
    void fsmSyncingParamcmdTryingQueued();
    void fsmSyncingDisconnect();
    void fsmSyncingDisconnectQueued();
    void fsmTryingParamcmdUp();
    void fsmTryingParamcmdUpQueued();
    void fsmTryingParamTrying();
    void fsmTryingParamTryingQueued();
    void fsmTryingDisconnect();
    void fsmTryingDisconnectQueued();
    void fsmUpParamcmdTrying();
    void fsmUpParamcmdTryingQueued();
    void fsmUpParamTrying();
    void fsmUpParamTryingQueued();
    void fsmUpDisconnect();
    void fsmUpDisconnectQueued();
    // trigger signals
    void startSignal(QPrivateSignal dummy);
    void stopSignal(QPrivateSignal dummy);
};
}; // namespace param
#endif //PARAM_CLIENT_H
